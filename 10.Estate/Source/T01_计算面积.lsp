;※※※※※※※※※※※※※※※(程序一[求单元面积])※※※※※※※※※※※※※※※
(defun c:MJ (/ pt sum ss)
  (setq rtosQW (atoi (dos_regget RegStr "oREALMJROUND")))
  (setq pt (getpoint "\n请选定注记位置(H代表半算):"))
  (setq pt (polar pt (* pi 0) -5))
  (setq sum 0)
  (while (setq ss (ssget '((0 . "LWPOLYLINE"))))
    (setq n1 -1)
    (setq pt (polar pt (* pi 0) 5))
    (while (setq s1 (ssname ss (setq n1 (1+ n1))))
      (setq xx (#DXFS 6 s1))
      (command "area" "o" s1)
      (setq m (getvar "area"))
      (if (or (= xx "6") (= xx "DASHED") (= xx "HIDDENX2"))
	(setq m (/ m 2)
	      qh "H"
	      YS 6)
	(setq qh "S"
	      YS 1) )
      (setq sum (+ sum m))
      (setq str (strcat qh  (rtos (+ n1 1 ) 2 0) "=" (rtos m 2 rtosQW)))
      (entmake (list '(0 . "TEXT") '(8 . "5说明注记")
		     (cons 10 (polar pt (* pi 1.5) (* 1 n1)))
		     (cons 62 YS)
		     '(40 . 0.5)
		     (cons 1 str))
	       )
      )
    )
  (if (not (null ss))
    (if (> (sslength ss) 1)
      (if (setq pt (getpoint))
	(#Entmake_Text4 (rtos sum 2 rtosQW) pt  0.5 "5说明注记")
	)
      )
    (princ "结束")
    )
  (princ))

(defun c:xs ()
  (setq ss (ssget (list (cons 0 "TEXT"))))
  (setq num (#sum ss))
  ;(princ (strcat "\n[S]= "(rtos num 2 3)))
  ;(#QS ss)
  (xyp_LX ss)
  (princ))

(defun c:xsa (/ ss1 ss1 sum1 sum2 )
  (setq ss1 (ssget "x" (list (cons 0 "TEXT")(cons 1 "S=*"))))
  (setq sum1 (#sum ss1))
  (princ (strcat "\n本幢总建S:"(rtos sum1 2 3)))
  (#QS ss)
  (princ))

(defun c:xsD (/ ss1 ss1 sum1 sum2 )
  (setq ss1 (ssget (list (cons 0 "TEXT")(cons 1 "*=*"))))
  (setq sum1 (#sum ss1))
  (princ (strcat "\n本幢总建S:"(rtos sum1 2 3)))
  (#QS ss)
  (princ))


;※※※※※※※※※※※※※※※(程序三[求文本差值])※※※※※※※※※※※※※※※
(defun c:xc ()
  (princ "文本差值")
  (setq strall "")
  (setq ss (ssget (list (cons 0 "TEXT"))))
  (setq n -1 num 0)
  (repeat 2
    (setq str (#DXFS 1 (ssname ss (setq n (1+ n)))))
    (if (setq pt (vl-string-search "=" str)) (setq str (substr str (+ 2 pt))) )
    (setq strall (strcat str " " strall))
    (setq num (- (atof str) num))
    )  
  (princ (strcat  "二者差值 " strall " XC=" (rtos (abs num) 2 3)))
  (entmake (list '(0 . "TEXT") '(8 . "5说明注记") (cons 10 (getpoint)) '(40 . 0.5) (cons 1 (strcat "差值="  (rtos (abs num) 2 3)))))
  (#QS ss)
  (princ))

(defun c:xDC ()
  (princ "多文本差值")
  (setq sszmj (ssget ":e" (list (cons 0 "TEXT"))))
  (setq s1 (ssname sszmj 0)) 
    (setq str (#DXFS 1 s1))
    (if (setq pt (vl-string-search "=" str)) (setq str (substr str (+ 2 pt))))
    (setq ZMJ  (atof str) )  
    (princ "选择被减数：")
  (setq ss (ssget (list (cons 0 "TEXT"))))
  (setq n1 -1 num 0)
  (while (setq s1 (ssname ss (setq n1 (1+ n1))))    
    (setq str (#DXFS 1 s1))
    (if (setq pt (vl-string-search "=" str)) (setq str (substr str (+ 2 pt))))
    (setq num (+ (atof str) num))
    )
  (setq num (-  ZMJ num))
  (if (setq pt (getpoint))
    (entmake (list '(0 . "TEXT") '(8 . "5说明注记") (cons 10 pt) '(40 . 0.5) (cons 1 (strcat "差值:" (rtos num 2 3)))))
    )
  (princ (strcat "差值:"(rtos num 2 3)))
  (princ))


(defun #sum (ss / n1 s1 str pt)
  ;(princ "文本求和")
  (setq n1 -1 num 0)
  (setq strall "")
  (while (setq s1 (ssname ss (setq n1 (1+ n1))))    
    (setq str (#DXFS 1 s1))
    (if (setq pt (vl-string-search "=" str)) (setq str (substr str (+ 2 pt))) )
    (setq strall (strcat str "+" strall))
    (setq num (+ (atof str) num))
    )
  (PRINC (strcat  "求和 " strall "\t[S]=" (rtos num 2 3)))
  (if (setq pt (getpoint))
    (entmake (list '(0 . "TEXT") '(8 . "5说明注记") (cons 10 pt) '(40 . 0.5)
		   (cons 1 (strcat (rtos n1 2 0) "[S]=" (rtos num 2 3)))))
    )
  num
)

(defun c:x0 ( / n1 s1 str pt)
  (setq strsymbol (getstring "输入符号："))
  (setq N (getreal (strcat "输入 " strsymbol " 数：")))
  (setq ss (ssget (list (cons 0 "TEXT"))))
  (setq n1 -1)
  (while (setq s1 (ssname ss (setq n1 (1+ n1))))    
    (setq str (#DXFS 1 s1))
    (if (setq pt (vl-string-search "=" str))
      (progn
	(setq strS (substr str 1 (+ 0 pt)))
	(setq strN (substr str (+ 2 pt)))
	(cond
	  ((= strsymbol "*")(setq strNN (rtos (* (distof strN 2) N) 2)))
	  ((= strsymbol "/")(setq strNN (rtos (/ (distof strN 2) N) 2)))
	  ((= strsymbol "+")(setq strNN (rtos (+ (distof strN 2) N) 2)))
	  ((= strsymbol "-")(setq strNN (rtos (- (distof strN 2) N) 2)))
	  )
	(setq str (strcat strS strsymbol (rtos N 2) "= " strN strsymbol (rtos N 2) " =" strNN))
	)
      (progn
	(setq strN str)
	(cond
	  ((= strsymbol "*")(setq strNN (rtos (* (distof strN 2) N) 2)))
	  ((= strsymbol "/")(setq strNN (rtos (/ (distof strN 2) N) 2)))
	  ((= strsymbol "+")(setq strNN (rtos (+ (distof strN 2) N) 2)))
	  ((= strsymbol "-")(setq strNN (rtos (- (distof strN 2) N) 2)))
	  )	
	(setq str (strcat strN strsymbol (rtos N 2) "=" strNN))
	)    
      );END-IF
    (princ str)
    (if (setq pt (getpoint))
      (entmake (list '(0 . "TEXT") '(8 . "080T") (cons 10 pt) '(40 . 0.5)  (cons 1 str)))
      )
    )
  (#QS ss)
  (PRINC))
  



(defun c:xvf (/ cc strlstSum)
  (princ "层面积")
  (setq strAll nil
	strlst nil
	strlst梯 nil
	strlstS nil)
  (setq ss (ssget (list (cons 0 "TEXT"))))
  (setq n1 -1)
  (while (setq s1 (ssname ss (setq n1 (1+ n1))))
    (setq strAll (append (#tddtext s1) strAll ))
    )
  (setq n1 -1)
  (while (setq str0 (nth (setq n1 (+ n1 1)) strAll))
    (setq tlist1 (#sparser str0 "=")
	  dm (car tlist1)
	  dm_end (atoi (substr dm (strlen dm) 1))) ;获取单元的类型
      (setq str (list dm_end (car tlist1) (cadr tlist1) str0))
      (cond
;;;	((wcmatch str0 "T*")(setq strlst梯 (append (list str) strlst梯)))
;;;	((wcmatch str0 "*S*")(setq strlstS (append (list str) strlstS)))
;;;	((OR (wcmatch str0 "*Q*")
;;;	     (wcmatch str0 "G*")
;;;	     (wcmatch str0 "DT*")
;;;	     (wcmatch str0 "JF*")
;;;	     )
;;;	     (setq strlstS (append (list str) strlstS)))
;;;	(T (setq strlst (append (list str) strlst)))
	
	((wcmatch str0 "T*")(setq strlst梯 (append (list str) strlst梯)))
	((wcmatch str0 "*S*")(setq strlstS (append (list str) strlstS)))
	((wcmatch str0 "0*,Y*,RF#=*,#=*,##=*,###=*")(setq strlstSum (append (list str) strlstSum)))
	(T (setq strlst (append (list str) strlst)))
	
	)
    )
;;;  (setq strlst (vl-sort strlst (function (lambda (e1 e2) (> (caddr e1) (caddr e2)))))) ;单元排序
;;;  (setq strlst (vl-sort strlst (function (lambda (e1 e2) (< (car e1) (car e2)))))) ;单元排序
;;;  (setq strlst梯 (vl-sort strlst梯 (function (lambda (e1 e2) (< (car e1) (car e2)))))) ;单元排序
;;;  (setq strlst (append strlst strlst梯 strlstS))
  (setq n2 -1)
  (setq num 0)
  (setq prlst nil)
  (while (setq str (nth (setq n2 (+ n2 1)) strlstSum))
    (setq num (+ (atof (caddr str)) num))
    (setq prlst (cons (caddr str) prlst))
    )
  (setq prlst (reverse prlst))
 (setq str (strcat (rtos n2 2 0) "[S]=" (rtos num 2 3)))
 (if (setq pt (getpoint))(#Entmake_Text4 str pt 0.5 "080T")   )
(princ))


;;;
;;;  (princ "1.选择层建筑面积 2.选择层建筑面积合计")
;;;  (setq ss (ssget (list (cons 0 "TEXT"))))
;;;  (setq pt1 (#DXFS 10 (ssname ss 0)))
;;;  (setq pt2 (#DXFS 10 (ssname ss 1)))
;;;  
;;;  (sub_upd (ssname ss 0) 1 pt2)
;;;  (sub_upd (ssname ss 1) 1 pt1)


;;;※※※※※※※※※※※※※※※(程序四[公墙])※※※※※※※※※※※※※※※
;;;(defun c:GQ ()
;;;  (command "LAYER"  "SET"  "权属层"  "OFF" "房屋层" "off" "数据注记" "on" "说明注记" "on" "0"*Cancel*)
;;;  (setvar "CLAYER" "说明注记")
;;;  (setvar "CECOLOR" "Bylayer")
;;;  (setvar "CELTYPE" "Continuous")
;;;  (setq pt (getpoint "\n请选定注记位置:"))
;;;  (setq ss (ssget '((0 . "LWPOLYLINE"))))
;;;  (setq n 0)
;;;  (setq s 0)
;;;     (repeat (sslength ss)
;;;       (setq name(ssname ss n))
;;;       (setq e(entget name))
;;;       (setq e1(cdr(assoc 6 e)))
;;;       (command "area" "o" name)
;;;       (setq m(getvar "area"))
;;;       (if (or (= e1 "DASHED") (= e1 "DASHED2")) (setq m(/ m 2)))
;;;       (setq m(atof(rtos m 2 3)))
;;;       (if (= n 0) (setq q m) (progn (setq s(+ s m)) (if (and (/= e1 "DASHED") (/= e1 "DASHED2")) (setq q (- q m)))))
;;;       (setq n(1+ n))
;;;     )
;;;(command ".text" "S" "STANDARD" pt 0.50 "0" (strcat "Q=" (rtos q 2 3)))
;;;(command ".text" "S" "STANDARD" (polar pt 0 5) 0.50 "0" (strcat "[S]=" (rtos (+ s q) 2 3)))
;;;(command ".text" "S" "STANDARD" (polar pt 0 11) 0.50 "0" (strcat "S=" (rtos (+ s q) 2 3)))
;;;)


(defun c:GQ (/ pt sum ss)
  (setq pt (getpoint "\n请选定注记位置:"))
  (setq pt (polar pt (* pi 0) -5))
  (setq sum 0 sumWQ 0)
  (setq ss (ssget '((0 . "LWPOLYLINE"))))
    (setq n1 -1)
    (setq pt (polar pt (* pi 0) 5))
    (while (setq s1 (ssname ss (setq n1 (1+ n1))))
      (setq xx (#DXFS 6 s1))
      (setq layer (#DXFS 8 s1))
      (command "area" "o" s1)
      (setq m (getvar "area"))
      (if (or (= xx "6") (= xx "DASHED") (= xx "HIDDENX2"))
	(setq m (/ m 2)
	      qh "H"
	      YS 6)
	(setq qh "S"
	      YS 1) )
(setq m (distof (rtos m 2 3) 2))
      (if  (= layer "3权属线")
	(setq sum (+ sum m))
	(setq sumWQ (+ sumWQ m))
	)
      )
  (setq sumQ (- sumWQ sum))
  ;(#Entmake_Text4 (rtos sum 2 3) (polar pt (* pi 0) 5)  0.5 "5说明注记")
  
 (#Entmake_Text4 (strcat "Q="(rtos (abs sumQ) 2 3)) (polar pt (* pi 0) 5)  0.5 "5说明注记")
  (#Entmake_Text4 (strcat "[S]="(rtos (abs sumWQ) 2 3)) (polar pt (* pi 0) 10)  0.5 "5说明注记")
  (#Entmake_Text4 (strcat "S="(rtos (abs sumWQ) 2 3)) (polar pt (* pi 0) 16)  0.5 "5说明注记")
 (princ))
